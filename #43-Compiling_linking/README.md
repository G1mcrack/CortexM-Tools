# STM32 C++ Compiling

## Prerequisites

GCC ARM Compiler

## GPIO Output Library

We will write our own `DigitalOut` and `DigitalIn` class in C++.

DigitalIn.h

```C++
#include "stm32f1xx_hal.h"

using namespace std;

class DigitalIn
{
public:
    DigitalIn(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t GPIO_Pull);
    ~DigitalIn();
    int read();
    operator int ();
private:
    GPIO_TypeDef *GPIOx;
    uint16_t GPIO_Pin;
};
```

### Remark

Constructor:

```C++
DigitalIn(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t GPIO_Pull);
```

**Parameters**

* GPIOx: `x` could be A..G (depend on the device used) to select the GPIO peripheral
* GPIO_Pin: specifies the port bit to be written. This parameter can be one of GPIO_PIN_x where x can be (0..15)
* GPIO_Pull: Specifies the Pull-up or Pull-down activation for the selected pins.
  * Possible values are: `GPIO_NOPULL`, `GPIO_PULLUP` and `GPIO_PULLDOWN`

***

DigitalOut.h

```C++
#include "stm32f1xx_hal.h"

using namespace std;

class DigitalOut
{
public:
    DigitalOut(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
    DigitalOut(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t GPIO_Mode, uint32_t GPIO_Speed);
    ~DigitalOut();
    void write(int value);
    int read();
    DigitalOut& operator= (int value);
    operator int ();
private:
    int state = 0;
    GPIO_TypeDef *GPIOx;
    uint16_t GPIO_Pin;
};
```

### Remark

Constructor:

```C++
DigitalOut(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin);
DigitalOut(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t GPIO_Mode, uint32_t GPIO_Speed);
```

**Parameters**

* GPIOx: `x` could be A..G (depend on the device used) to select the GPIO peripheral
* GPIO_Pin: specifies the port bit to be written. This parameter can be one of GPIO_PIN_x where x can be (0..15)
* GPIO_Mode: Specifies the operating mode for the selected pin 
  * Possible values are: `GPIO_MODE_OUTPUT_PP` and `GPIO_MODE_OUTPUT_OD`
* GPIO_Speed: Specifies the speed for the selected pins 
  * Possible values are: `GPIO_SPEED_LOW`, `GPIO_SPEED_MEDIUM`, `GPIO_SPEED_HIGH`

## Makefile

The `Makefile` generated by CubeMX need to be modified a lot in order to support C++ compilation and control the size of the program.

### Specify the `Debug` flag and optimize the release build for size

```Makefile
# debug build?
DEBUG = 0
# optimization
ifeq ($(DEBUG), 1)
OPT = -Og
else
OPT = -Os
endif
```

### Specify the C++ sources

```Makefile
CPP_SOURCES = \
Src/DigitalOut.cpp \
Src/DigitalIn.cpp \
Src/main.cpp
```

### Specify the C++ compiler and linker

```Makefile
PREFIX = arm-none-eabi-
CC = $(PREFIX)gcc
CXX = $(PREFIX)g++
#AS = $(PREFIX)gcc -x assembler-with-cpp
AS = $(PREFIX)g++ -x assembler
```

### Specify the compiler flags

```Makefile
# compile gcc flags
ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections -fno-exceptions

CFLAGS = $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections -fno-exceptions

CXXFLAGS = $(CFLAGS) -fno-rtti
```

**Note:**

* `-fno-exceptions` is used in order to ruduce the binary size after linking the `stdc++` library
* No need for RTTI in microcontroller, so `-fno-rtti` is also added to `CXXFLAGS`

### Specify the libraries

```Makefile
# libraries
LIBS = -lc -lm -lnosys -lstdc++_nano
LIBDIR = 
LDFLAGS = $(MCU) -specs=nano.specs -specs=nosys.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections
```

**Note:**

* Link the `stdc++_nano` library, which is a C++ library optimized for code size.
* ARM GNU Toolchain supports Bare metal ARM EABI by default. So, there will be no system calls enabled and functions such as malloc will not work as expected.

  Set of system calls implementation are present with this toolchain. They can be selected using the specs.

  Example:
  ```
  $ arm-none-eabi-gcc --specs=nano.specs $(OTHER_LINK_OPTIONS)
  $ arm-none-eabi-gcc --specs=nosys.specs $(OTHER_LINK_OPTIONS)
  ```

  These specs lets gcc to select library newlib-nano or libnosys.a that contains the system calls such as _sbrk. 
  
  Nosys library contains set of default syscall stubs, majority of the stubs just returns failure. It need to be included in this C++ project or there will be unresolved symbols.

### Specify the build application

```Makefile
#######################################
# build the application
#######################################
# list of objects
OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))
vpath %.c $(sort $(dir $(C_SOURCES)))
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(CPP_SOURCES:.cpp=.o)))
vpath %.cpp $(sort $(dir $(CPP_SOURCES)))
# list of ASM program objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))
vpath %.s $(sort $(dir $(ASM_SOURCES)))

$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) 
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.cpp Makefile | $(BUILD_DIR) 
	$(CXX) -c $(CXXFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.cpp=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)
	$(AS) -c $(CXXFLAGS) $< -o $@

$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile
	$(CXX) $(OBJECTS) $(LDFLAGS) -o $@
	$(SZ) $@

$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(HEX) $< $@
	
$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(BIN) $< $@	
	
$(BUILD_DIR):
	mkdir $@
```

**Note:**

Be sure to use `CXX` to compile the `.cpp` code and to link the entire project.



